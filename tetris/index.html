<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tetris</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #1a1a2e;
    color: #eee;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    overflow: hidden;
  }

  .game-container {
    display: flex;
    gap: 24px;
    align-items: flex-start;
  }

  .side-panel {
    display: flex;
    flex-direction: column;
    gap: 16px;
    min-width: 130px;
  }

  .panel-box {
    background: #16213e;
    border: 2px solid #0f3460;
    border-radius: 8px;
    padding: 12px;
    text-align: center;
  }

  .panel-box h3 {
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: #e94560;
    margin-bottom: 8px;
  }

  .panel-box .value {
    font-size: 22px;
    font-weight: bold;
  }

  #game-canvas {
    border: 3px solid #0f3460;
    border-radius: 4px;
    background: #0a0a1a;
    display: block;
  }

  #next-canvas {
    display: block;
    margin: 0 auto;
  }

  .controls-info {
    font-size: 11px;
    line-height: 1.8;
    color: #888;
  }

  .controls-info kbd {
    background: #0f3460;
    padding: 2px 6px;
    border-radius: 3px;
    font-family: monospace;
    color: #e94560;
  }

  /* Start / Game Over overlay */
  #overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: rgba(10, 10, 26, 0.85);
    z-index: 10;
    pointer-events: auto;
  }

  #overlay.hidden { display: none; }

  #overlay h1 {
    font-size: 48px;
    color: #e94560;
    margin-bottom: 8px;
  }

  #overlay .subtitle {
    font-size: 16px;
    color: #aaa;
    margin-bottom: 24px;
  }

  #overlay button {
    background: #e94560;
    color: #fff;
    border: none;
    padding: 12px 32px;
    font-size: 18px;
    border-radius: 6px;
    cursor: pointer;
    transition: background 0.2s;
  }

  #overlay button:hover {
    background: #c73652;
  }

  .board-wrapper {
    position: relative;
  }

  #game-over-text {
    display: none;
    font-size: 14px;
    color: #e94560;
    margin-bottom: 12px;
  }

  /* Pause Menu overlay */
  #pause-overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: rgba(10, 10, 26, 0.90);
    z-index: 20;
    pointer-events: auto;
  }

  #pause-overlay.hidden { display: none; }

  #pause-overlay h1 {
    font-size: 42px;
    color: #e94560;
    margin-bottom: 24px;
  }

  .pause-menu {
    background: #16213e;
    border: 2px solid #0f3460;
    border-radius: 10px;
    padding: 24px 32px;
    min-width: 260px;
    display: flex;
    flex-direction: column;
    gap: 18px;
    align-items: center;
  }

  .settings-section {
    width: 100%;
  }

  .settings-section h3 {
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: #e94560;
    margin-bottom: 12px;
    text-align: center;
  }

  .setting-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
  }

  .setting-row label {
    font-size: 14px;
    color: #ccc;
  }

  .setting-row .input-group {
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .setting-row input[type="number"] {
    width: 60px;
    padding: 4px 8px;
    font-size: 14px;
    border: 1px solid #0f3460;
    border-radius: 4px;
    background: #0a0a1a;
    color: #eee;
    text-align: center;
    -moz-appearance: textfield;
  }

  .setting-row input[type="number"]::-webkit-outer-spin-button,
  .setting-row input[type="number"]::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  .setting-note {
    font-size: 11px;
    color: #666;
    text-align: center;
    margin-top: -4px;
  }

  .pause-menu button {
    background: #e94560;
    color: #fff;
    border: none;
    padding: 10px 28px;
    font-size: 16px;
    border-radius: 6px;
    cursor: pointer;
    transition: background 0.2s;
    width: 100%;
  }

  .pause-menu button:hover {
    background: #c73652;
  }

  .pause-menu button.secondary {
    background: #0f3460;
  }

  .pause-menu button.secondary:hover {
    background: #1a4a8a;
  }

  .pause-divider {
    width: 100%;
    height: 1px;
    background: #0f3460;
  }
</style>
</head>
<body>

<div class="game-container">
  <div class="side-panel">
    <div class="panel-box">
      <h3>Score</h3>
      <div class="value" id="score">0</div>
    </div>
    <div class="panel-box">
      <h3>Level</h3>
      <div class="value" id="level">1</div>
    </div>
    <div class="panel-box">
      <h3>Lines</h3>
      <div class="value" id="lines">0</div>
    </div>
    <div class="panel-box">
      <h3>Next</h3>
      <canvas id="next-canvas" width="100" height="100"></canvas>
    </div>
  </div>

  <div class="board-wrapper">
    <canvas id="game-canvas" width="300" height="600"></canvas>

    <!-- Start / Game Over overlay -->
    <div id="overlay">
      <h1>TETRIS</h1>
      <div id="game-over-text">Game Over!</div>
      <div class="subtitle">Classic block-stacking game</div>
      <button id="start-btn">Play</button>
    </div>

    <!-- Pause Menu overlay -->
    <div id="pause-overlay" class="hidden">
      <h1>PAUSED</h1>
      <div class="pause-menu">
        <div class="settings-section">
          <h3>Settings</h3>
          <div class="setting-row">
            <label for="setting-width">Field Width</label>
            <div class="input-group">
              <input type="number" id="setting-width" min="5" value="10">
            </div>
          </div>
          <div class="setting-note">Min: 5 · Takes effect on next game</div>
        </div>
        <div class="pause-divider"></div>
        <button id="resume-btn">Resume</button>
        <button id="restart-btn" class="secondary">Restart with Settings</button>
      </div>
    </div>
  </div>

  <div class="side-panel">
    <div class="panel-box">
      <h3>Controls</h3>
      <div class="controls-info">
        <kbd>←</kbd> <kbd>→</kbd> Move<br>
        <kbd>↑</kbd> Rotate<br>
        <kbd>↓</kbd> Soft Drop<br>
        <kbd>Space</kbd> Hard Drop<br>
        <kbd>Esc</kbd> / <kbd>P</kbd> Pause
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // --- Constants ---
  const ROWS = 20;
  const BLOCK = 30;
  const NEXT_BLOCK = 20;

  // --- Configurable settings ---
  let cols = 10;

  const COLORS = [
    null,
    '#00f0f0', // I - cyan
    '#f0f000', // O - yellow
    '#a000f0', // T - purple
    '#00f000', // S - green
    '#f00000', // Z - red
    '#0000f0', // J - blue
    '#f0a000', // L - orange
  ];

  // SRS piece definitions: [row, col] offsets for each rotation state
  const PIECES = [
    null,
    // I
    [
      [[1,0],[1,1],[1,2],[1,3]],
      [[0,2],[1,2],[2,2],[3,2]],
      [[2,0],[2,1],[2,2],[2,3]],
      [[0,1],[1,1],[2,1],[3,1]],
    ],
    // O
    [
      [[0,1],[0,2],[1,1],[1,2]],
      [[0,1],[0,2],[1,1],[1,2]],
      [[0,1],[0,2],[1,1],[1,2]],
      [[0,1],[0,2],[1,1],[1,2]],
    ],
    // T
    [
      [[0,1],[1,0],[1,1],[1,2]],
      [[0,1],[1,1],[1,2],[2,1]],
      [[1,0],[1,1],[1,2],[2,1]],
      [[0,1],[1,0],[1,1],[2,1]],
    ],
    // S
    [
      [[0,1],[0,2],[1,0],[1,1]],
      [[0,1],[1,1],[1,2],[2,2]],
      [[1,1],[1,2],[2,0],[2,1]],
      [[0,0],[1,0],[1,1],[2,1]],
    ],
    // Z
    [
      [[0,0],[0,1],[1,1],[1,2]],
      [[0,2],[1,1],[1,2],[2,1]],
      [[1,0],[1,1],[2,1],[2,2]],
      [[0,1],[1,0],[1,1],[2,0]],
    ],
    // J
    [
      [[0,0],[1,0],[1,1],[1,2]],
      [[0,1],[0,2],[1,1],[2,1]],
      [[1,0],[1,1],[1,2],[2,2]],
      [[0,1],[1,1],[2,0],[2,1]],
    ],
    // L
    [
      [[0,2],[1,0],[1,1],[1,2]],
      [[0,1],[1,1],[2,1],[2,2]],
      [[1,0],[1,1],[1,2],[2,0]],
      [[0,0],[0,1],[1,1],[2,1]],
    ],
  ];

  // SRS Wall Kick data
  const KICKS_JLSTZ = {
    '0>1': [[0,0],[0,-1],[-1,-1],[2,0],[2,-1]],
    '1>2': [[0,0],[0,1],[1,1],[-2,0],[-2,1]],
    '2>3': [[0,0],[0,1],[-1,1],[2,0],[2,1]],
    '3>0': [[0,0],[0,-1],[1,-1],[-2,0],[-2,-1]],
  };
  const KICKS_I = {
    '0>1': [[0,0],[0,-2],[0,1],[1,-2],[-2,1]],
    '1>2': [[0,0],[0,2],[0,-1],[-1,2],[2,-1]],
    '2>3': [[0,0],[0,-1],[0,2],[-2,-1],[1,2]],
    '3>0': [[0,0],[0,1],[0,-2],[2,1],[-1,-2]],
  };

  // --- DOM ---
  const canvas = document.getElementById('game-canvas');
  const ctx = canvas.getContext('2d');
  const nextCanvas = document.getElementById('next-canvas');
  const nextCtx = nextCanvas.getContext('2d');
  const overlay = document.getElementById('overlay');
  const pauseOverlay = document.getElementById('pause-overlay');
  const startBtn = document.getElementById('start-btn');
  const resumeBtn = document.getElementById('resume-btn');
  const restartBtn = document.getElementById('restart-btn');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const linesEl = document.getElementById('lines');
  const gameOverText = document.getElementById('game-over-text');
  const settingWidth = document.getElementById('setting-width');

  // --- Game State ---
  let board, current, next, score, lines, level, gameOver, paused;
  let dropInterval, dropTimer, animFrameId;
  let lastTime = 0;

  // Scoring
  const LINE_POINTS = [0, 100, 300, 500, 800];

  function resizeCanvas() {
    canvas.width = cols * BLOCK;
    canvas.height = ROWS * BLOCK;
  }

  function createBoard() {
    return Array.from({ length: ROWS }, () => new Array(cols).fill(0));
  }

  function randomPiece() {
    const id = Math.floor(Math.random() * 7) + 1;
    // Center the piece horizontally; pieces use a 4-wide bounding box
    const spawnCol = Math.floor((cols - 4) / 2);
    return { id, rot: 0, row: -1, col: spawnCol };
  }

  function getBlocks(piece) {
    return PIECES[piece.id][piece.rot].map(([r, c]) => [piece.row + r, piece.col + c]);
  }

  function isValid(piece) {
    return getBlocks(piece).every(([r, c]) =>
      r < ROWS && c >= 0 && c < cols && (r < 0 || board[r][c] === 0)
    );
  }

  function lock(piece) {
    getBlocks(piece).forEach(([r, c]) => {
      if (r >= 0) board[r][c] = piece.id;
    });
  }

  function clearLines() {
    let cleared = 0;
    for (let r = ROWS - 1; r >= 0; r--) {
      if (board[r].every(v => v !== 0)) {
        board.splice(r, 1);
        board.unshift(new Array(cols).fill(0));
        cleared++;
        r++;
      }
    }
    if (cleared > 0) {
      lines += cleared;
      score += LINE_POINTS[cleared] * level;
      const newLevel = Math.floor(lines / 10) + 1;
      if (newLevel !== level) {
        level = newLevel;
        dropInterval = Math.max(50, 1000 - (level - 1) * 80);
      }
      updateUI();
    }
  }

  function updateUI() {
    scoreEl.textContent = score;
    levelEl.textContent = level;
    linesEl.textContent = lines;
  }

  // --- Drawing ---
  function drawBlock(context, x, y, colorIdx, size) {
    const color = COLORS[colorIdx];
    context.fillStyle = color;
    context.fillRect(x + 1, y + 1, size - 2, size - 2);
    context.fillStyle = 'rgba(255,255,255,0.18)';
    context.fillRect(x + 1, y + 1, size - 2, 4);
    context.fillRect(x + 1, y + 1, 4, size - 2);
    context.fillStyle = 'rgba(0,0,0,0.25)';
    context.fillRect(x + size - 4, y + 1, 3, size - 2);
    context.fillRect(x + 1, y + size - 4, size - 2, 3);
  }

  function drawBoard() {
    ctx.fillStyle = '#0a0a1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Grid lines
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    for (let r = 0; r <= ROWS; r++) {
      ctx.beginPath();
      ctx.moveTo(0, r * BLOCK);
      ctx.lineTo(cols * BLOCK, r * BLOCK);
      ctx.stroke();
    }
    for (let c = 0; c <= cols; c++) {
      ctx.beginPath();
      ctx.moveTo(c * BLOCK, 0);
      ctx.lineTo(c * BLOCK, ROWS * BLOCK);
      ctx.stroke();
    }

    // Placed blocks
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < cols; c++) {
        if (board[r][c]) {
          drawBlock(ctx, c * BLOCK, r * BLOCK, board[r][c], BLOCK);
        }
      }
    }

    // Ghost piece
    if (current) {
      const ghost = { ...current };
      while (isValid({ ...ghost, row: ghost.row + 1 })) ghost.row++;
      getBlocks(ghost).forEach(([r, c]) => {
        if (r >= 0) {
          ctx.strokeStyle = COLORS[ghost.id];
          ctx.globalAlpha = 0.3;
          ctx.strokeRect(c * BLOCK + 2, r * BLOCK + 2, BLOCK - 4, BLOCK - 4);
          ctx.globalAlpha = 1;
        }
      });
    }

    // Current piece
    if (current) {
      getBlocks(current).forEach(([r, c]) => {
        if (r >= 0) {
          drawBlock(ctx, c * BLOCK, r * BLOCK, current.id, BLOCK);
        }
      });
    }
  }

  function drawNext() {
    nextCtx.fillStyle = '#16213e';
    nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
    if (!next) return;
    const blocks = PIECES[next.id][0];
    const minR = Math.min(...blocks.map(b => b[0]));
    const maxR = Math.max(...blocks.map(b => b[0]));
    const minC = Math.min(...blocks.map(b => b[1]));
    const maxC = Math.max(...blocks.map(b => b[1]));
    const h = maxR - minR + 1;
    const w = maxC - minC + 1;
    const offsetX = (nextCanvas.width - w * NEXT_BLOCK) / 2 - minC * NEXT_BLOCK;
    const offsetY = (nextCanvas.height - h * NEXT_BLOCK) / 2 - minR * NEXT_BLOCK;
    blocks.forEach(([r, c]) => {
      drawBlock(nextCtx, offsetX + c * NEXT_BLOCK, offsetY + r * NEXT_BLOCK, next.id, NEXT_BLOCK);
    });
  }

  // --- Pause Menu ---
  function showPauseMenu() {
    paused = true;
    settingWidth.value = cols;
    pauseOverlay.classList.remove('hidden');
  }

  function hidePauseMenu() {
    pauseOverlay.classList.add('hidden');
    paused = false;
    lastTime = performance.now();
  }

  function readSettings() {
    let w = parseInt(settingWidth.value, 10);
    if (isNaN(w) || w < 5) w = 5;
    settingWidth.value = w;
    return { width: w };
  }

  function applySettings(settings) {
    cols = settings.width;
    resizeCanvas();
  }

  // --- Game Logic ---
  function spawn() {
    current = next || randomPiece();
    next = randomPiece();
    if (!isValid(current)) {
      gameOver = true;
      endGame();
    }
    drawNext();
  }

  function moveDown() {
    const test = { ...current, row: current.row + 1 };
    if (isValid(test)) {
      current.row++;
    } else {
      lock(current);
      clearLines();
      spawn();
    }
  }

  function moveLeft() {
    const test = { ...current, col: current.col - 1 };
    if (isValid(test)) current.col--;
  }

  function moveRight() {
    const test = { ...current, col: current.col + 1 };
    if (isValid(test)) current.col++;
  }

  function rotate() {
    const oldRot = current.rot;
    const newRot = (oldRot + 1) % 4;
    const kickKey = `${oldRot}>${newRot}`;
    if (current.id === 2) return;
    const kickTable = current.id === 1 ? KICKS_I : KICKS_JLSTZ;
    const kicks = kickTable[kickKey];
    if (!kicks) return;
    for (const [dr, dc] of kicks) {
      const test = { ...current, rot: newRot, row: current.row + dr, col: current.col + dc };
      if (isValid(test)) {
        current.rot = newRot;
        current.row = test.row;
        current.col = test.col;
        return;
      }
    }
  }

  function hardDrop() {
    while (true) {
      const test = { ...current, row: current.row + 1 };
      if (isValid(test)) {
        current.row++;
        score += 2;
      } else break;
    }
    lock(current);
    clearLines();
    updateUI();
    spawn();
  }

  // --- Game Loop ---
  function gameLoop(time) {
    if (gameOver) return;
    if (paused) {
      animFrameId = requestAnimationFrame(gameLoop);
      return;
    }
    const delta = time - lastTime;
    dropTimer += delta;
    lastTime = time;

    if (dropTimer >= dropInterval) {
      moveDown();
      dropTimer = 0;
    }

    drawBoard();
    animFrameId = requestAnimationFrame(gameLoop);
  }

  function startGame() {
    // Apply settings before starting
    const settings = readSettings();
    applySettings(settings);

    board = createBoard();
    score = 0;
    lines = 0;
    level = 1;
    gameOver = false;
    paused = false;
    dropInterval = 1000;
    dropTimer = 0;
    lastTime = performance.now();
    current = null;
    next = null;
    updateUI();
    spawn();
    drawBoard();
    overlay.classList.add('hidden');
    pauseOverlay.classList.add('hidden');
    gameOverText.style.display = 'none';
    if (animFrameId) cancelAnimationFrame(animFrameId);
    animFrameId = requestAnimationFrame(gameLoop);
  }

  function endGame() {
    gameOver = true;
    gameOverText.style.display = 'block';
    startBtn.textContent = 'Play Again';
    overlay.querySelector('.subtitle').textContent = `Score: ${score}  •  Level: ${level}`;
    overlay.classList.remove('hidden');
  }

  // --- Input ---
  document.addEventListener('keydown', (e) => {
    // Allow toggling pause menu even when paused (but not when game over or not started)
    if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') {
      if (gameOver) return;
      // Don't allow pause if game hasn't started (overlay is showing)
      if (!overlay.classList.contains('hidden')) return;

      if (paused) {
        hidePauseMenu();
      } else {
        showPauseMenu();
      }
      return;
    }

    if (gameOver || paused) return;

    switch (e.key) {
      case 'ArrowLeft':
        e.preventDefault();
        moveLeft();
        break;
      case 'ArrowRight':
        e.preventDefault();
        moveRight();
        break;
      case 'ArrowDown':
        e.preventDefault();
        moveDown();
        score += 1;
        updateUI();
        break;
      case 'ArrowUp':
        e.preventDefault();
        rotate();
        break;
      case ' ':
        e.preventDefault();
        hardDrop();
        break;
    }
  });

  startBtn.addEventListener('click', startGame);
  resumeBtn.addEventListener('click', hidePauseMenu);
  restartBtn.addEventListener('click', () => {
    hidePauseMenu();
    startGame();
  });

  // Enforce minimum width of 5 on blur
  settingWidth.addEventListener('blur', () => {
    let v = parseInt(settingWidth.value, 10);
    if (isNaN(v) || v < 5) {
      settingWidth.value = 5;
    }
  });

  // Initial draw
  resizeCanvas();
  drawBoard();
})();
</script>

</body>
</html>